package pattern

import "fmt"

/*
	Реализовать паттерн «комманда».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern


	Приминяемость
Когда вы хотите параметризовать объекты выполняемым действием.
 Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов.
Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать
 меню в разных приложениях, не меняя каждый раз код ваших классов.
 Применив паттерн, пользователям не придётся изменять классы меню,
 вместо этого они будут конфигурировать объекты меню различными командами.
 Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
 Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку,
 чтобы потом сохранить в файл или базу данных. Затем в любой удобный момент её можно достать обратно,
  снова превратить в объект команды и выполнить. Таким же образом команды можно передавать по сети,
  логировать или выполнять на удалённом сервере.
 Когда вам нужна операция отмены.
 Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов, которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.
История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением операции сохраняет текущее состояние объекта, с которым она будет работать. После выполнения операции копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.
Этот способ имеет две особенности. Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн Снимок.
Во-вторых, копии состояния могут занимать довольно много оперативной памяти. Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния команда выполняет обратное действие. Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.

Приемущества:
Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
 Позволяет реализовать простую отмену и повтор операций.
 Позволяет реализовать отложенный запуск операций.
 Позволяет собирать сложные команды из простых.
 Реализует принцип открытости/закрытости.
недостатки:
 Усложняет код программы из-за введения множества дополнительных классов.
*/

type Button struct {
	Command
}

func (b *Button) Press() {
	b.Execute()
}

type Command interface {
	Execute()
}

type OneCommand struct {
	Device
}

func (oc *OneCommand) Execute() {
	oc.One()
}

type TwoCommnad struct {
	Device
}

func (wc *TwoCommnad) Execute() {
	wc.Two()
}

type Device interface {
	One()
	Two()
}

type Recipient struct {
	result string
}

func (r *Recipient) One() {
	r.result = "One Command"
	fmt.Println(r.result)
}

func (r *Recipient) Two() {
	r.result = "Two Command"
	fmt.Println(r.result)
}
